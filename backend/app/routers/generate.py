"""Generate router - Create new content cards using Nano Banana Pro for images."""

import json
import logging

from fastapi import APIRouter, HTTPException, Request

from app.config import get_model
from app.models.canvas_config import validate_card_or_raise
from app.models.ephemeral import GenerateRequest, GenerateResponse
from app.services.prompt_loader import load_and_fill_prompt
from app.services.xml_parser import parse_card_response

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api", tags=["ephemeral"])

async def _generate_image_card(
    gemini,
    user_composition: str,
    config_name: str,
) -> dict:
    """Generate an image card using Nano Banana Pro (gemini-3-pro-image-preview).

    Uses actual AI image generation, not stock photo search.
    Returns base64 image data for direct display.
    """
    # Build prompt for image generation (loaded from prompts/image_generation.md)
    prompt = load_and_fill_prompt(
        "image_generation",
        user_context=user_composition or "creative inspiration and artistic expression",
        config_name=config_name,
    )

    logger.info(f"Generating image with Nano Banana Pro. Context: {user_composition[:100] if user_composition else 'none'}...")

    # Generate image using Nano Banana Pro (gemini-3-pro-image-preview)
    # This uses response_modalities=["TEXT", "IMAGE"] to get actual AI-generated images
    result = await gemini.generate_image(
        prompt=prompt,
        model="gemini-3-pro-image-preview",  # Explicitly use Nano Banana Pro
    )

    logger.info(f"Image generation result: text={bool(result.text)}, images={len(result.images)}")

    if not result.images:
        logger.warning("No images generated by Nano Banana Pro")
        raise ValueError("Image generation failed - no images returned")

    # Get the first generated image
    img = result.images[0]
    base64_data = img["data"]
    mime_type = img.get("mime_type", "image/png")

    # Create data URL for direct embedding
    data_url = f"data:{mime_type};base64,{base64_data}"

    # Generate a caption from the text response if available
    caption = result.text if result.text else "AI-generated image"
    if len(caption) > 100:
        caption = caption[:97] + "..."

    logger.info(f"Image generated successfully. MIME: {mime_type}, caption: {caption[:50]}...")

    return {
        "image_url": data_url,
        "thumbnail": data_url,  # Same as main for AI-generated
        "caption": caption,
        "attribution": "Generated by Nano Banana Pro (Gemini)",
        "is_ai_generated": True,
    }


@router.post("/generate")
async def generate(request_data: GenerateRequest, request: Request) -> GenerateResponse:
    """Generate new content based on config.

    Model is determined by config.models.generation.
    Returns card with cost tracking information.
    """
    try:
        gemini = request.app.state.gemini_service
        if not gemini:
            raise HTTPException(status_code=503, detail="Gemini service not initialized")

        # Get model
        gen_model = request_data.config.models.generation
        gemini_model = get_model(gen_model)

        # Handle image card generation - always uses Nano Banana Pro
        if request_data.image_card:
            card = await _generate_image_card(
                gemini,
                request_data.user_composition,
                request_data.config.name,
            )
            return GenerateResponse(card=card, cost_usd=None, usage=None)

        # Format the card schema as JSON
        schema_json = json.dumps(request_data.config.cardSchema.model_dump(), indent=2)

        # Format existing cards for context
        existing_str = "(none)"
        if request_data.existing_cards:
            lines = [f"{i}. {json.dumps(card)}" for i, card in enumerate(request_data.existing_cards, 1)]
            existing_str = "\n".join(lines)

        # Build directive section (only if directive provided)
        directive_section = ""
        if request_data.directive:
            directive_section = f"""<diversity_directive>
For this generation, follow this creative direction:
{request_data.directive}
</diversity_directive>"""

        # Load and fill the prompt template
        prompt = load_and_fill_prompt(
            "generate",
            config_name=request_data.config.name,
            user_composition=request_data.user_composition or "(none)",
            card_schema=schema_json,
            generation_context=request_data.config.generationContext,
            directive_section=directive_section,
            existing_cards=existing_str,
            image_card_section="",
        )

        # Query Gemini
        result = await gemini.query(prompt, model=gemini_model)
        card = parse_card_response(result.text)

        # Validate LLM output against schema
        validate_card_or_raise(card, request_data.config.cardSchema)

        return GenerateResponse(card=card, cost_usd=None, usage=result.usage)

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Generate error: {type(e).__name__}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=503, detail=f"Generation error: {str(e)}")
